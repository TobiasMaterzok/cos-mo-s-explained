<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>COS(M+O)S: Interactive Explainer</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Merriweather:ital,wght@0,300;0,700;1,300&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; color: #1e293b; overflow: hidden; margin: 0; }
        h1, h2, h3, .serif { font-family: 'Merriweather', serif; }
        
        .glass-panel { 
            background: rgba(255, 255, 255, 0.85); 
            backdrop-filter: blur(20px); 
            border: 1px solid rgba(255,255,255,0.8);
            box-shadow: 0 20px 40px -10px rgba(0,0,0,0.1);
        }

        .fade-enter { opacity: 0; transform: translateY(20px); transition: opacity 0.6s cubic-bezier(0.16, 1, 0.3, 1), transform 0.6s cubic-bezier(0.16, 1, 0.3, 1); }
        .fade-active { opacity: 1; transform: translateY(0); }
        
        .bar-fill { transition: width 1.5s cubic-bezier(0.22, 1, 0.36, 1); }

        /* --- TITLE HOVER ANIMATION --- */
        .acronym-container {
            display: inline-flex;
            align-items: baseline;
            cursor: pointer;
        }
        
        .hidden-text {
            display: inline-block;
            max-width: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-width 0.5s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.4s ease;
            white-space: nowrap;
            font-size: 0.65em; 
            color: #64748b;   /* Slate 500 */
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            letter-spacing: 0.05em;
            transform: translateY(-2px);
        }

        .header-group:hover .hidden-text,
        .header-group.active .hidden-text {
            max-width: 60px; 
            opacity: 1;
            margin-left: 2px;
            margin-right: 2px;
        }

        .bracket {
            color: #94a3b8;
            transition: color 0.3s ease;
        }
        .header-group:hover .bracket,
        .header-group.active .bracket {
            color: #475569;
        }

        /* --- POPUP LEGEND --- */
        #legend-card {
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
        }
        #legend-card.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }
    </style>
</head>
<body>

    <div class="flex flex-col md:flex-row w-screen h-screen overflow-hidden">
        
        <!-- RIGHT PANEL (3D SCENE) -->
        <div class="order-1 md:order-2 w-full h-[55%] md:h-full md:flex-1 relative bg-[#f0f2f5] overflow-hidden z-10">
            <div id="canvas-container" class="w-full h-full cursor-move"></div>
            
            <!-- Overlay Label -->
            <div class="absolute bottom-6 w-full pointer-events-none flex justify-center">
                <div id="viz-label" class="glass-panel px-6 py-3 rounded-2xl text-slate-600 text-xs md:text-sm font-medium tracking-wide shadow-2xl transition-all transform hover:scale-105 duration-500 text-center mx-4">
                    Schematic Visualization
                </div>
            </div>
            
            <!-- Vignette -->
            <div class="absolute inset-0 pointer-events-none bg-[radial-gradient(circle_at_center,transparent_20%,rgba(200,210,230,0.4)_100%)]"></div>
        </div>

        <!-- LEFT PANEL (TEXT CONTENT) -->
        <div class="order-2 md:order-1 w-full md:w-1/3 md:min-w-[450px] h-[45%] md:h-full bg-white/95 border-t md:border-t-0 md:border-r border-slate-200 z-20 flex flex-col shadow-[0_-10px_40px_rgba(0,0,0,0.1)] md:shadow-2xl relative rounded-t-3xl md:rounded-none">
            
            <!-- Header -->
            <div class="p-5 md:p-8 border-b border-slate-100 bg-slate-50/50 header-group relative group rounded-t-3xl md:rounded-none" id="main-header">
                <h1 class="text-2xl md:text-3xl font-bold text-slate-900 tracking-tight flex items-baseline flex-wrap select-none cursor-pointer" onclick="toggleLegend()">
                    <span>COS</span>
                    <span class="acronym-container mx-0.5">
                        <span class="bracket">(</span>
                        <span class="text-orange-600">M</span>
                        <span class="hidden-text">CTS</span>
                        <span class="mx-0.5 text-slate-300 group-hover:text-slate-400 transition-colors">+</span>
                        <span class="text-blue-600">O</span>
                        <span class="hidden-text">RPO</span>
                        <span class="bracket">)</span>
                    </span>
                    <span>S</span>
                </h1>
                
                <!-- LEGEND POPUP -->
                <div id="legend-card" class="absolute top-16 left-4 right-4 md:left-8 md:right-8 bg-white border border-slate-200 rounded-xl shadow-xl p-4 z-50">
                    <div class="text-[10px] uppercase tracking-widest font-bold text-slate-400 mb-3 border-b border-slate-100 pb-2">Methodology Breakdown</div>
                    
                    <div class="space-y-3">
                        <div class="flex items-start gap-3">
                            <div class="w-8 text-right font-bold text-slate-700">COS</div>
                            <div class="text-xs text-slate-500 leading-relaxed">
                                <span class="font-semibold text-slate-800">
                                    Curiosity-Oriented Step-Level Strategy
                                </span><br>
                                Evaluates partial stories with a "Goldilocks" surprisal metric and
                                feeds those signals into the search (M) and policy update (O) steps.
                            </div>
                        </div>
                        
                        <div class="flex items-start gap-3">
                            <div class="w-8 text-right font-bold text-orange-600">M</div>
                            <div class="text-xs text-slate-500 leading-relaxed">
                                <span class="font-semibold text-slate-800">Monte Carlo Tree Search</span><br>
                                <span class="italic">System 2 Inference.</span> Explores the story space to find high-value paths.
                            </div>
                        </div>

                        <div class="flex items-start gap-3">
                            <div class="w-8 text-right font-bold text-blue-600">O</div>
                            <div class="text-xs text-slate-500 leading-relaxed">
                                <span class="font-semibold text-slate-800">ORPO</span><br>
                                <span class="italic">Policy Update.</span> Internalizes the search results into the model weights.
                            </div>
                        </div>
                    </div>
                </div>

                <p class="hidden md:block text-sm text-slate-500 mt-3 font-serif italic leading-relaxed">
                    Curiosity and RL-Enhanced MCTS for Exploring Story Space via Language Models
                </p>
                
                <!-- Author & Link -->
                <div class="flex flex-row items-center justify-between mt-2 md:mt-6 md:flex-col md:items-start md:gap-3">
                    <div class="text-[10px] font-bold text-slate-400 uppercase tracking-widest">
                        Tobias Materzok
                    </div>
                    <a href="https://arxiv.org/abs/2501.17104" target="_blank" class="group/btn flex items-center gap-2 px-3 py-1.5 bg-slate-100 hover:bg-orange-50 rounded-full border border-slate-200 hover:border-orange-200 transition-all duration-300">
                        <span class="text-[10px] font-bold text-slate-600 group-hover/btn:text-orange-600 uppercase tracking-widest">Read Paper</span>
                        <svg class="w-3 h-3 text-slate-400 group-hover/btn:text-orange-500 transform group-hover/btn:translate-x-0.5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                        </svg>
                    </a>
                </div>
            </div>

            <!-- Content -->
            <!-- FIX: Removed 'justify-center'. Added 'my-auto' to child for safe vertical centering. -->
            <div id="content-area" class="flex-1 p-5 md:p-8 overflow-y-auto flex flex-col bg-white">
                <div id="slide-content" class="fade-active w-full my-auto">
                    <div id="step-indicator" class="inline-block px-3 py-1 mb-3 md:mb-5 text-[10px] font-bold tracking-widest text-orange-600 uppercase bg-orange-50 rounded-full border border-orange-100">
                        Concept 1 / 7
                    </div>
                    <h2 id="slide-title" class="text-2xl md:text-3xl font-bold text-slate-800 mb-2 serif">Title</h2>
                    <h3 id="slide-subtitle" class="text-sm md:text-lg text-slate-500 mb-4 md:mb-6 font-light">Subtitle</h3>
                    <div id="slide-text" class="text-slate-600 leading-relaxed text-sm md:text-base mb-6 md:mb-8">
                        Text content goes here...
                    </div>

                    <!-- Stats -->
                    <div id="stat-container" class="bg-slate-50 p-4 md:p-6 rounded-xl border border-slate-100">
                        <div id="simple-stat">
                            <div id="stat-value" class="text-2xl md:text-4xl font-bold text-slate-900 tracking-tight">Value</div>
                            <div id="stat-label" class="text-[10px] md:text-xs text-slate-500 uppercase tracking-wide mt-1 font-semibold">Label</div>
                        </div>
                        
                        <div id="chart-stat" class="hidden w-full">
                            <div class="text-[10px] text-slate-400 uppercase tracking-widest font-bold mb-4 border-b border-slate-200 pb-2">GPT-4o Quality Rating (SD)</div>
                            <div class="space-y-4 md:space-y-5">
                                <div>
                                    <div class="flex justify-between text-xs text-slate-500 mb-1 font-medium">
                                        <span>Llama 3.2 3B (Baseline)</span>
                                        <span>0.0 SD</span>
                                    </div>
                                    <div class="w-full bg-slate-200 rounded-full h-1.5 overflow-hidden">
                                        <div class="h-full bg-slate-400 w-0.5"></div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between text-xs text-orange-700 mb-1 font-bold">
                                        <span>COS(M+O)S (3B)</span>
                                        <span>+0.59 SD</span>
                                    </div>
                                    <div class="w-full bg-orange-100 rounded-full h-1.5 overflow-hidden">
                                        <div class="h-full bg-orange-500 w-[90.7%] bar-fill shadow-[0_0_15px_rgba(249,115,22,0.5)]"></div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between text-xs text-slate-600 mb-1 font-semibold">
                                        <span>Llama 3.1 70B</span>
                                        <span>+0.65 SD</span>
                                    </div>
                                    <div class="w-full bg-slate-200 rounded-full h-1.5 overflow-hidden">
                                        <div class="h-full bg-slate-700 w-[100%] bar-fill"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-3 md:mt-4 text-[10px] text-slate-400 italic text-right">
                                n=18 stories, 50 evals each.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <div class="p-4 md:p-6 border-t border-slate-100 bg-white flex justify-between items-center">
                <button id="prev-btn" class="px-4 md:px-5 py-2 md:py-2.5 rounded-lg text-xs md:text-sm font-medium text-slate-500 hover:bg-slate-50 transition-colors disabled:opacity-30 disabled:cursor-not-allowed">
                    Back
                </button>
                <div class="flex space-x-1.5 md:space-x-2" id="dots-container"></div>
                <button id="next-btn" class="px-5 md:px-6 py-2 md:py-2.5 rounded-lg bg-slate-900 text-white text-xs md:text-sm font-medium shadow-lg hover:bg-slate-800 hover:shadow-xl transition-all transform hover:-translate-y-0.5 disabled:opacity-50 disabled:cursor-not-allowed">
                    Next
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- TOGGLE LOGIC ---
        function toggleLegend() {
            const header = document.getElementById('main-header');
            const legend = document.getElementById('legend-card');
            
            if (legend.classList.contains('visible')) {
                legend.classList.remove('visible');
                header.classList.remove('active');
            } else {
                legend.classList.add('visible');
                header.classList.add('active'); 
            }
        }
        
        document.addEventListener('click', function(event) {
            const header = document.getElementById('main-header');
            const legend = document.getElementById('legend-card');
            const isClickInside = header.contains(event.target);
            
            if (!isClickInside && legend.classList.contains('visible')) {
                toggleLegend();
            }
        });

        // --- CONTENT CONFIG ---
        const content = [
            {
                title: "The System 1 Limitation",
                subtitle: "Standard LLM Storytelling",
                text: "LLMs typically generate stories in a single pass (System 1). This autoregressive approach picks the next likely token, often resulting in predictable, formulaic plots without long-term planning.",
                stat: "Single Pass",
                statLabel: "Autoregressive Decoding",
                vizLabel: "Schematic: Standard Linear Path",
                vizType: 0
            },
            {
                title: "COS(M+O)S: System 2 Search",
                subtitle: "Exploring the Story Space",
                text: "We introduce COS(M+O)S: A framework that treats plot writing as a search problem. Using <b>MCTS</b> with <b>UCB selection</b> and <b>dynamic branching</b>, we explore many possible plot directions before committing.",
                stat: "MCTS",
                statLabel: "Iterative Exploration",
                vizLabel: "Schematic: MCTS Exploration",
                vizType: 1
            },
            {
                title: "Step-Level Value Modeling",
                subtitle: "Knowing Good from Bad",
                text: "We use a Step-Level Value Model V(s) to evaluate partial plots. Crucially, we use <b>Deferred Evaluation</b> (scoring after 50% completion). This assigns <b>Partial Credit</b>, allowing us to prune bad branches early while nurturing promising ones.",
                stat: "V(s)",
                statLabel: "Partial Evaluation (>50%)",
                vizLabel: "Schematic: <span class='text-orange-500 font-bold'>High Value</span> vs <span class='text-blue-400 font-bold'>Low Value</span>",
                vizType: 2
            },
            {
                title: "The Curiosity Index",
                subtitle: "The 'Simulated Reader'",
                text: "We operationalize the concept of <b>Flow</b>. By measuring surprisal with a 3B model (Phi-3.5), we capture <b>subjective novelty</b> relative to its specific cognitive capacity.<br><br>Our tuning found that when reading a <b>Good Story</b>, the surprisal peaks at <b>4 bits</b>:<br>• <b>Low Surprisal:</b> Boring Cliché.<br>• <b>High Surprisal:</b> Incoherent Noise.",
                stat: "4 Bits",
                statLabel: "Optimal Surprisal (S₀)",
                vizLabel: "Schematic: Curiosity Manifold (Inverted-U)",
                vizType: 3
            },
            {
                title: "ORPO: The RL Loop",
                subtitle: "Iterative Self-Improvement",
                text: "We use MCTS as an 'Expert' to find high-value paths, then use ORPO to update the 'Student' policy. This creates an <b>Iterative Reinforcement Learning</b> cycle (Expert Iteration). The fine-tuned policy reaches high-quality (+20%) solutions <b>1.9x faster</b> than the base model using MCTS alone.",
                stat: "1.9x Faster",
                statLabel: "Search Convergence (at 20% threshold)",
                vizLabel: "Schematic: <span class='text-orange-500 font-bold'>Chosen Path</span> vs <span class='text-slate-400 font-bold'>Rejected Options</span>",
                vizType: 4
            },
            {
                title: "Results: Closing the Gap",
                subtitle: "Approaching 70B Parity",
                text: "With this framework, the small 3B model significantly improves upon its baseline. GPT-4o ratings place COS(M+O)S 0.59 SD above the naive 3B baseline, narrowing the gap to the 70B model (difference not statistically significant, p=0.93).",
                stat: "CHART", 
                statLabel: "",
                vizLabel: "Schematic: Optimized Policy",
                vizType: 5
            },
            {
                title: "Limitations & Caveats",
                subtitle: "Academic Context",
                text: "While promising, absolute story quality remains modest. The statistical parity with 70B (p=0.93) refers specifically to <b>GPT-4o's aggregate rating</b> across 9 literary dimensions (e.g., Structure, Tension). It does not imply parity in human-perceived prose style or world knowledge.",
                stat: "N=18",
                statLabel: "Small Sample Size",
                vizLabel: "Schematic: Modest Absolute Quality",
                vizType: 6
            }
        ];

        // --- UI LOGIC ---
        let currentStep = 0;
        const dom = {
            title: document.getElementById('slide-title'),
            subtitle: document.getElementById('slide-subtitle'),
            text: document.getElementById('slide-text'),
            stepInd: document.getElementById('step-indicator'),
            statSimple: document.getElementById('simple-stat'),
            statChart: document.getElementById('chart-stat'),
            statValue: document.getElementById('stat-value'),
            statLabel: document.getElementById('stat-label'),
            vizLabel: document.getElementById('viz-label'),
            prevBtn: document.getElementById('prev-btn'),
            nextBtn: document.getElementById('next-btn'),
            dots: document.getElementById('dots-container'),
            slideContainer: document.getElementById('slide-content')
        };

        content.forEach((_, i) => {
            const dot = document.createElement('div');
            dot.className = `h-1.5 rounded-full transition-all duration-500 ${i === 0 ? 'w-6 bg-orange-500' : 'w-1.5 bg-slate-300'}`;
            dom.dots.appendChild(dot);
        });

        function updateUI() {
            dom.slideContainer.classList.remove('fade-active');
            dom.slideContainer.classList.add('fade-enter');

            setTimeout(() => {
                const data = content[currentStep];
                dom.title.textContent = data.title;
                dom.subtitle.textContent = data.subtitle;
                dom.text.innerHTML = data.text;
                dom.stepInd.textContent = `Concept ${currentStep + 1} / ${content.length}`;
                dom.vizLabel.innerHTML = data.vizLabel;

                if (window.MathJax) MathJax.typesetPromise([dom.text]);

                if(data.stat === 'CHART') {
                    dom.statSimple.classList.add('hidden');
                    dom.statChart.classList.remove('hidden');
                } else {
                    dom.statSimple.classList.remove('hidden');
                    dom.statChart.classList.add('hidden');
                    dom.statValue.textContent = data.stat;
                    dom.statLabel.textContent = data.statLabel;
                }

                dom.prevBtn.disabled = currentStep === 0;
                dom.nextBtn.disabled = currentStep === content.length - 1;
                dom.nextBtn.textContent = currentStep === content.length - 1 ? "Finish" : "Next";

                Array.from(dom.dots.children).forEach((dot, i) => {
                    dot.className = `h-1.5 rounded-full transition-all duration-500 ${i === currentStep ? 'w-6 bg-orange-500' : 'w-1.5 bg-slate-300'}`;
                });

                dom.slideContainer.classList.remove('fade-enter');
                dom.slideContainer.classList.add('fade-active');
                updateScene(data.vizType);
            }, 200);
        }

        dom.nextBtn.onclick = () => { if(currentStep < content.length - 1) { currentStep++; updateUI(); } };
        dom.prevBtn.onclick = () => { if(currentStep > 0) { currentStep--; updateUI(); } };

        // --- 3D SCENE ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f2f5); 
        scene.fog = new THREE.FogExp2(0xf0f2f5, 0.035); 

        const camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(0, 0, 18); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);
        const keyLight = new THREE.DirectionalLight(0xfff0dd, 1.0); 
        keyLight.position.set(5, 10, 7);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 1024;
        keyLight.shadow.mapSize.height = 1024;
        scene.add(keyLight);
        const rimLight = new THREE.SpotLight(0xdbeafe, 2.0); 
        rimLight.position.set(-10, 5, -10);
        rimLight.lookAt(0,0,0);
        scene.add(rimLight);
        const fillLight = new THREE.PointLight(0xe2e8f0, 0.5);
        fillLight.position.set(0, -5, 5);
        scene.add(fillLight);

        let objects = [];
        let activeSignals = []; 
        let sceneStartTime = 0; 

        // --- MATERIALS ---
        const matNodeDefault = new THREE.MeshPhysicalMaterial({ color: 0xcbd5e1, roughness: 0.2, metalness: 0.1, clearcoat: 1.0, clearcoatRoughness: 0.1 });
        const matNodeGood = new THREE.MeshPhysicalMaterial({ color: 0xf97316, emissive: 0xc2410c, emissiveIntensity: 0.2, roughness: 0.2, metalness: 0.3, clearcoat: 1.0 });
        const matNodeBad = new THREE.MeshPhysicalMaterial({ color: 0x64748b, roughness: 0.7, metalness: 0.0, clearcoat: 0.0 });
        const matNodeBlue = new THREE.MeshPhysicalMaterial({ color: 0x3b82f6, roughness: 0.3, metalness: 0.1, clearcoat: 1.0 });
        const geoSphere = new THREE.IcosahedronGeometry(1, 1); 

        function clearScene() { 
            objects.forEach(obj => {
                if(obj.material) {
                    if(Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                    else obj.material.dispose();
                }
                if(obj.geometry) obj.geometry.dispose();
                scene.remove(obj);
            }); 
            objects = []; activeSignals = []; 
        }

        // --- SHADERS ---
        const vertexShaderTrace = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
        const fragmentShaderTrace = `uniform float progress; uniform vec3 color; varying vec2 vUv; void main() { if (vUv.x > progress) discard; float edge = smoothstep(progress - 0.1, progress, vUv.x); float core = 1.0 - abs(vUv.y - 0.5) * 2.0; float glow = smoothstep(0.4, 1.0, core); vec3 finalColor = mix(color, vec3(1.0, 1.0, 1.0), max(edge, glow * 0.6)); gl_FragColor = vec4(finalColor, 1.0); }`;

        // --- TRACE CLASS ---
        class GrowingTrace {
            constructor(curvePath, color, speed = 0.2, initialDelay = 0.0, maxProgress = 1.0) {
                const geometry = new THREE.TubeGeometry(curvePath, 256, 0.03, 8, false);
                const material = new THREE.ShaderMaterial({
                    uniforms: { progress: { value: 0.0 }, color: { value: new THREE.Color(color) } },
                    vertexShader: vertexShaderTrace, fragmentShader: fragmentShaderTrace,
                    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
                });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh); objects.push(this.mesh);
                this.speed = 0.002 * speed; 
                this.startDelay = initialDelay; 
                this.maxProgress = maxProgress; 
            }
            update(globalProgress) {
                if (globalProgress < this.startDelay) { this.mesh.material.uniforms.progress.value = 0.0; return; }
                const effectiveDuration = 1.0 - this.startDelay;
                let p = (globalProgress - this.startDelay) * (1.0 / effectiveDuration);
                if (p > this.maxProgress) p = this.maxProgress; 
                this.mesh.material.uniforms.progress.value = p;
            }
            hold() { this.mesh.material.uniforms.progress.value = this.maxProgress; }
            reset() { this.mesh.material.uniforms.progress.value = 0.0; }
        }

        // --- HELPERS ---
        function createCurvedLine(start, end, color, opacity) {
            const mid = start.clone().add(end).multiplyScalar(0.5);
            mid.add(new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5));
            const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
            const points = curve.getPoints(24); 
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: opacity, linecap: 'round', linejoin: 'round' });
            const line = new THREE.Line(geometry, material);
            scene.add(line); objects.push(line);
            return curve;
        }
        function createNode(pos, type = 'default', scale = 0.15) {
            let mat = matNodeDefault;
            if(type === 'good') mat = matNodeGood; if(type === 'bad') mat = matNodeBad; if(type === 'blue') mat = matNodeBlue; if(type === 'root') scale *= 1.5;
            const mesh = new THREE.Mesh(geoSphere, mat);
            mesh.position.copy(pos); mesh.scale.set(scale, scale, scale);
            mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            scene.add(mesh); objects.push(mesh);
            return mesh;
        }

        // --- BUILDERS ---
        function buildTreeData(depth, showValue) {
            // FIXED: DEPTH 4 (Cleanest)
            const rootPos = new THREE.Vector3(0, 4, 0);
            createNode(rootPos, 'root');
            const rootNode = { pos: rootPos, children: [], type: 'root' };
            const generate = (parentNode, currentDepth) => {
                if(currentDepth >= depth) return;
                const count = currentDepth < 2 ? 3 : 2; 
                for(let i=0; i<count; i++) {
                    // FIXED: Wider Spread for Depth 4
                    const layerSpread = (4.0 - currentDepth * 0.5); 
                    const angleBase = (i / count) * Math.PI * 2; 
                    const angle = angleBase + (Math.random() * 0.8 - 0.4);
                    const radius = layerSpread * (0.6 + Math.random() * 0.4);
                    const childPos = new THREE.Vector3(
                        parentNode.pos.x + Math.cos(angle) * radius * 0.8,
                        parentNode.pos.y - 1.5 - (Math.random() * 0.5),
                        parentNode.pos.z + Math.sin(angle) * radius * 0.5
                    );
                    let type = 'default'; let lineColor = 0x94a3b8; let lineOp = 0.4;
                    if(showValue && currentDepth > 0) {
                        const dist = Math.sqrt(childPos.x*childPos.x + childPos.z*childPos.z);
                        if(dist < 1.2 + (currentDepth * 0.6)) { type = 'good'; lineColor = 0xf97316; lineOp = 0.8; } 
                        else { type = 'blue'; lineColor = 0x60a5fa; lineOp = 0.2; }
                    } else if (!showValue && depth === 1) { type = 'default'; lineColor = 0x94a3b8; }
                    createNode(childPos, type, 0.15); // Slightly larger nodes for Depth 4
                    const curve = createCurvedLine(parentNode.pos, childPos, lineColor, lineOp);
                    const childNode = { pos: childPos, children: [], type: type };
                    parentNode.children.push({ node: childNode, curve: curve });
                    generate(childNode, currentDepth + 1);
                }
            };
            if(depth === 1) {
                let currNode = rootNode;
                for(let i=0; i<5; i++) {
                    let nextPos = currNode.pos.clone().add(new THREE.Vector3((Math.random()-0.5)*0.8, -1.5, (Math.random()-0.5)*0.8));
                    createNode(nextPos, 'default', 0.15);
                    const curve = createCurvedLine(currNode.pos, nextPos, 0x94a3b8, 0.4);
                    const nextNode = { pos: nextPos, children: [], type: 'default' };
                    currNode.children.push({ node: nextNode, curve: curve });
                    currNode = nextNode;
                }
            } else { generate(rootNode, 0); }
            return rootNode;
        }

        function generateSearchTraces(node, currentPath = []) {
            if(node.children.length === 0 && currentPath.length > 0) return [currentPath];
            let paths = [];
            node.children.forEach(childObj => {
                const childPaths = generateSearchTraces(childObj.node, [...currentPath, childObj.curve]);
                paths = paths.concat(childPaths);
            });
            return paths;
        }

        // --- SCENES ---
        function sceneSystem1() {
            const root = buildTreeData(1, false);
            const allPaths = generateSearchTraces(root);
            const curvePath = new THREE.CurvePath();
            allPaths[0].forEach(c => curvePath.add(c));
            activeSignals.push(new GrowingTrace(curvePath, 0xffaa00, 1.0, 0.0));
        }
        function sceneMCTS() {
            // FIXED: Depth 4
            const root = buildTreeData(4, false);
            const allPaths = generateSearchTraces(root);
            const shuffled = allPaths.sort(() => 0.5 - Math.random());
            shuffled.slice(0, 6).forEach((pathCurves, idx) => {
                const curvePath = new THREE.CurvePath();
                pathCurves.forEach(c => curvePath.add(c));
                activeSignals.push(new GrowingTrace(curvePath, 0xffb700, 1.0, idx * 0.05));
            });
        }
        function sceneValue() {
            const root = buildTreeData(4, true);
            const allPaths = generateSearchTraces(root);
            const shuffled = allPaths.sort(() => 0.5 - Math.random());
            const selected = shuffled.slice(0, 8); 
            selected.forEach((pathCurves, idx) => {
                const lastCurve = pathCurves[pathCurves.length-1];
                const endPt = lastCurve.v2;
                const dist = Math.sqrt(endPt.x*endPt.x + endPt.z*endPt.z);
                const isGood = dist < 2.0;
                const curvePath = new THREE.CurvePath();
                pathCurves.forEach(c => curvePath.add(c));
                if (isGood) {
                    activeSignals.push(new GrowingTrace(curvePath, 0xffaa00, 1.0, idx * 0.08, 1.0));
                } else {
                    // Bad: Full growth now
                    activeSignals.push(new GrowingTrace(curvePath, 0xa5f3fc, 1.0, idx * 0.08, 1.0)); 
                }
            });
        }
        function buildCuriosity() {
            const particleCount = 2000; const geo = new THREE.BufferGeometry(); const positions = []; const colors = []; const colorObj = new THREE.Color();
            for(let i=0; i<particleCount; i++) {
                const x = (Math.random() - 0.5) * 14; const z = (Math.random() - 0.5) * 14; 
                const dist = Math.sqrt(x*x + z*z); const interest = Math.exp(-Math.pow(dist, 2) / 12.0);
                const y = (interest * 5 - 2.5) + (Math.sin(x*2)*0.2 + Math.cos(z*2)*0.2)*0.3;
                positions.push(x, y, z);
                colorObj.setHSL(0.6 - (interest * 0.55), 0.8, 0.5 + interest * 0.3); colors.push(colorObj.r, colorObj.g, colorObj.b);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 0.18, vertexColors: true, transparent: true, opacity: 0.8, sizeAttenuation: true });
            const points = new THREE.Points(geo, mat); scene.add(points); objects.push(points);
            const grid = new THREE.GridHelper(30, 30, 0xe2e8f0, 0xf1f5f9); grid.position.y = -3; scene.add(grid); objects.push(grid);
        }
        function buildORPOPairs() {
            const root = new THREE.Vector3(0, 4, 0); let curr = root.clone(); createNode(curr, 'root');
            const mainPath = new THREE.CurvePath();
            for(let i=0; i<5; i++) {
                const next = curr.clone().add(new THREE.Vector3(0.5, -1.5, (Math.random()-0.5)*0.5));
                createNode(next, 'good', 0.2);
                const curve = createCurvedLine(curr, next, 0xf97316, 0.3); mainPath.add(curve);
                const rejectedCount = 2 + Math.floor(Math.random()*2);
                for(let j=0; j<rejectedCount; j++) {
                    const rX = -1.0 - (Math.random()*1.5); const rY = -1.2 + (Math.random()*0.5); const rZ = (Math.random()-0.5) * 3;
                    const reject = curr.clone().add(new THREE.Vector3(rX, rY, rZ));
                    createNode(reject, 'bad', 0.1); createCurvedLine(curr, reject, 0x94a3b8, 0.2);
                }
                curr = next;
            }
            activeSignals.push(new GrowingTrace(mainPath, 0xffb700, 1.0, 0.0));
        }
        function buildFinalPath() {
            const root = new THREE.Vector3(0, 4, 0); let curr = root.clone(); createNode(curr, 'root');
            const mainPath = new THREE.CurvePath();
            for(let i=0; i<6; i++) {
                const next = curr.clone().add(new THREE.Vector3(0, -1.5, 0));
                next.x += (Math.random()-0.5)*0.2; next.z += (Math.random()-0.5)*0.2;
                createNode(next, 'good', 0.25);
                const curve = createCurvedLine(curr, next, 0xf97316, 0.4); mainPath.add(curve);
                curr = next;
            }
            activeSignals.push(new GrowingTrace(mainPath, 0xffd700, 1.0, 0.0));
        }
        function buildLimitations() {
             const root = buildTreeData(4, false); // Fixed Depth 4
             const dustGeo = new THREE.BufferGeometry(); const dPos = [];
             for(let i=0; i<500; i++) { dPos.push((Math.random()-0.5)*15, (Math.random()-0.5)*15, (Math.random()-0.5)*15); }
             dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dPos, 3));
             const dustMat = new THREE.PointsMaterial({color: 0x64748b, size: 0.05, transparent: true, opacity: 0.5});
             const dust = new THREE.Points(dustGeo, dustMat); scene.add(dust); objects.push(dust);
        }

        function updateScene(type) {
            clearScene(); sceneStartTime = clock.getElapsedTime();
            if (type !== 6) {
                const dustGeo = new THREE.BufferGeometry(); const dPos = [];
                for(let i=0; i<200; i++) { dPos.push((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20); }
                dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dPos, 3));
                const dustMat = new THREE.PointsMaterial({color: 0x94a3b8, size: 0.03, transparent: true, opacity: 0.3});
                const dust = new THREE.Points(dustGeo, dustMat); scene.add(dust); objects.push(dust);
            }
            switch(type) {
                case 0: sceneSystem1(); break;
                case 1: sceneMCTS(); break; 
                case 2: sceneValue(); break; 
                case 3: buildCuriosity(); break;
                case 4: buildORPOPairs(); break; 
                case 5: buildFinalPath(); break; 
                case 6: buildLimitations(); break;
            }
        }

        let isDragging = false; let prevMouse = { x: 0, y: 0 };
        container.addEventListener('mousedown', () => isDragging = true);
        window.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mousemove', (e) => {
            if(isDragging) { const dx = e.clientX - prevMouse.x; scene.rotation.y += dx * 0.003; }
            prevMouse = { x: e.clientX, y: e.clientY };
        });

        // Touch events for mobile
        container.addEventListener('touchstart', (e) => {
            isDragging = true;
            prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        window.addEventListener('touchend', () => { isDragging = false; });
        container.addEventListener('touchmove', (e) => {
            if(isDragging) {
                const dx = e.touches[0].clientX - prevMouse.x;
                scene.rotation.y += dx * 0.003;
                prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const currentTime = clock.getElapsedTime();
            if(!isDragging) scene.rotation.y = Math.sin(currentTime * 0.1) * 0.2; 
            const localTime = currentTime - sceneStartTime;
            const cycleDuration = 6.0; const t = localTime % cycleDuration;
            if (t < 3.0) { const growProgress = t / 3.0; activeSignals.forEach(s => s.update(growProgress)); }
            else if (t < 5.0) { activeSignals.forEach(s => s.hold()); }
            else { activeSignals.forEach(s => s.reset()); }
            objects.forEach((obj, i) => { if(obj instanceof THREE.Mesh && obj.geometry.type === 'IcosahedronGeometry') obj.position.y += Math.sin(currentTime * 2 + i) * 0.001; });
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth, container.clientHeight);
        });
        updateScene(0); animate(); updateUI();
    </script>
</body>
</html>
